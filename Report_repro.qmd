---
title: "Report_Template"
editor: source
format: 
 html:
   embed-resources: true
   toc: true
   toc-location: left
execute:
    echo: false
    message: false
    warning: false
---

```{r}
library(tidyverse)
library(arrow)
library(dtplyr)
library(DT)
library(survival)
library(survminer)
library(stringr)
library(viridis)
library(RColorBrewer)
library(flextable)
library(officer)
library(gtsummary)
library(cardx)
library(htmltools)
library(lubridate)
library(httr)
library(jsonlite)
library(gt)
library(scales)

# Initialization and organization of initial data sets

source('functions/DT_base.R') #functions to parse remarks and protocols

# Intialize animal and animal lactation file and assign data pull date to an object for later use.
animals <- read_parquet('data/intermediate_files/animals.parquet')

animal_lactations<-read_parquet('data/intermediate_files/animal_lactations.parquet') 

pull_date <- unique(animals$data_pull_date_max)

date_start <- pull_date - 365 # pulls last year of data, modify for specific project

events_formatted <-read_parquet('data/intermediate_files/events_formatted.parquet')

# Pull the wanted information into a new data sets (double check in DC that the events are actually being recorded under these event names)

# Mastitis
mastitis_data <- events_formatted %>%
  filter(event %in% c("MAST"))

# Lameness
lame_data <- events_formatted %>%
  filter(event %in% c("LAME"))

# Reroduction
repro_data <- events_formatted %>%
  filter(event_type %in% c("repro"))%>%
  select(id_animal, id_animal_lact, 
         date_birth, lact_number, event, date_event,
         dim_event, R, date_concieved)

vwp <- 50 # Set to herd's VWP

# Youngstock
youngstock_data <- events_formatted%>%
  filter(lact_number == 0)

# Pull production data from dairy comp and re-format:
# EVENTS ID BDAT LACT\4S730 (730 = last 2 years of data, change based on goals)
# Save in data/intermediate_files/production_data. It should be the only file in there

# Define file path
# production_file <- "data/intermediate_files/production_data/production.parquet"
# 
# # Read Parquet file
# production_data <- read_parquet(production_file)
# 
# # Reformat the data
# production_data <- production_data %>%
#   mutate(
#     id_animal = paste0(as.character(ID), "_", as.character(BDAT)) #Create id_animal
#   ) %>%
#   rename(id = ID) %>%  
#   rename(date_birth = BDAT)%>%
#   rename(date_test = TestDate) %>%  
#   mutate(date_test = mdy(date_test))%>% # Convert to Date (Adjust format if needed)
#   relocate(id_animal, .before = everything())  # Move id_animal to the first column
# 


```


# Reproduction - TBD

```{r}
# 21 Day Preg Risk
date_end <- pull_date

# Create periods (21-day intervals)
periods <- seq(date_start, date_end, by = "21 days")

# Ensure lact_number > 0 and only repro events that affect elig.
repro_data <- repro_data %>%
  filter(lact_number > 0, event %in% c("PREG", 
                                       "ABORT", "BRED", 
                                       "OK", "OPEN", "DNB")
         ) |> 
  filter(lact_number != 32) |> 
  #filter out already pregnant cows (ie date_concieved has to be > date_start)
  filter(date_concieved > date_start | is.na(date_concieved))

# Assign time periods to repro data
repro_data <- repro_data %>%
  mutate(
    period_number = findInterval(date_event, periods, rightmost.closed = TRUE),
    period_start_date = periods[pmax(period_number, 1)],  # Assign start date
    period_end_date = period_start_date + 20,  # 21-day period
    period_end_date = case_when(
      period_end_date > date_end ~ date_end,  # Reset if > date_end
      TRUE ~ period_end_date  # Otherwise, keep the calculated end date
    )
  )

# set up animal data
animals_repro <- animal_lactations %>% 
  filter(lact_number > 0) %>%
  filter(lact_number != 32) |> 
  filter(date_archive >= date_start | is.na(date_archive)) %>% 
  select(id_animal_lact, date_fresh, date_archive) 

# Create row for every animal in every period
all_periods <- animals_repro %>%
  distinct(id_animal_lact) %>%  # Get unique id_animal_lact
  mutate(id_animal_lact = as.character(id_animal_lact)) %>%  # Ensure it's character type for joining
  crossing(period_start_date = periods) %>%  # Cross join with periods to get 18 rows per id_animal_lact
  mutate(
    period_end_date = period_start_date + 20,  # Assign 21-day period
    period_number = match(period_start_date, periods)  # Assign period number based on periods vector
  )

# Merge with existing animal_repro data
animals_repro <- all_periods %>%
  left_join(animals_repro, by = c("id_animal_lact")) %>%
  filter(is.na(date_archive) | date_archive > period_start_date) |> 
  group_by(id_animal_lact) %>%
  fill(date_fresh, date_archive, .direction = "downup") %>%  # Ensure lact info is copied
  ungroup()

# Ensure data is sorted by animal and period
animals_repro <- animals_repro %>%
  arrange(id_animal_lact, period_start_date) %>% 
  mutate(date_vwp = date_fresh + vwp)

# set up event data 
events_filtered <- events_formatted %>%
  filter(event %in% c("PREG", "ABORT")) |> 
  filter(lact_number != 32) |> 
  filter(date_concieved >= date_start)

# Set up event data with period information (matching the structure of animals_repro)
events_filtered_test <- events_filtered %>%
  # Ensure the correct period info is in the events data by matching on period numbers
  left_join(
    animals_repro %>%
      select(id_animal_lact, period_number, period_start_date, period_end_date),
    )
  

# Get the latest PREG and ABORT event before each period_start_date
latest_events <- events_filtered_test %>%
  # Keep only events that happened before the period_start_date (in the same period)
  filter(date_event < period_end_date) %>%
  group_by(id_animal_lact, period_number, period_start_date, period_end_date) %>%
  summarise(
    # Get the latest PREG event before the period_end_date
    latest_preg_event = max(if_else(event == "PREG", date_event, as.Date(0)), na.rm = TRUE),
    # Get the latest ABORT event before the period_end_date
    latest_abort_event = max(if_else(event == "ABORT", date_event, as.Date(0)), na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    latest_preg_event = as.Date(latest_preg_event),
    latest_preg_event = if_else(latest_preg_event == "1970-01-01", NA,latest_preg_event),
    latest_abort_event = as.Date(latest_abort_event),
     latest_abort_event = if_else(latest_abort_event == "1970-01-01", NA,latest_abort_event)
    )|> 
  ungroup()

# Merge the latest PREG and ABORT event dates back into animals_repro
animals_repro <- animals_repro %>%
  left_join(latest_events, by = c("id_animal_lact", "period_number", "period_start_date", "period_end_date"))


# Merge data - assign events to animal and period
animals_repro <- animals_repro %>%
  left_join(
    repro_data %>% 
      select(id_animal_lact, period_start_date, event, R, 
             period_number, period_end_date, date_concieved), 
    by = c("id_animal_lact", "period_start_date", "period_end_date", "period_number")
  )

# Pregnancy status based on the latest events
animals_repro <- animals_repro %>%
  mutate(
    pregnant_status = case_when(
      # If the event is "PREG", set pregnant_status to 1
      event == "PREG" ~ "1",
      # If there is an abort event that is after the last preg event and the last        abort date is before the end of the period, she is not pregnant
      !is.na(latest_abort_event) & latest_abort_event > latest_preg_event & latest_abort_event <= period_start_date ~ "0",
      # If there is a fresh date and the fresh date is after the last preg event         date and the fresh date is before the period start date, she is not pregnant
      !is.na(date_fresh) & date_fresh > latest_preg_event & date_fresh <= period_start_date ~ "0", 
      # If there is a valid preg date and there is no abort date or the last abort         date is before the preg date and there is no fresh date or the fresh date          is before the preg date then she is pregnant
      !is.na(latest_preg_event) & (is.na(latest_abort_event) | latest_abort_event < latest_preg_event | latest_abort_event > period_end_date) &
        (is.na(date_fresh) | date_fresh < latest_preg_event) ~ "1",
      # For any animals that do not meet the criteria listed above, they are listed       as not pregnant
      TRUE ~ "0"
    )
  )

animals_repro <- animals_repro %>%
  mutate(
    date_vwp = as.Date(date_vwp),
    period_start_date = as.Date(period_start_date),
    period_end_date = as.Date(period_end_date)
  )

# VWP logic, if VWP date is < period end date than eligible at some point in period so assign 1
animals_repro <- animals_repro %>%
  mutate(
    vwp_status = case_when(
      is.na(date_vwp) ~ NA_real_,  # If date_vwp is NA, return NA (you can change this to any default value you want)
      date_vwp <= period_end_date ~ 1,
      date_vwp > period_end_date ~ 0,
      TRUE ~ NA_real_  # You can handle any edge cases if necessary
    )
  )

animals_repro <- animals_repro %>% 
  group_by(id_animal_lact, period_end_date) %>%
  # if there is a bred event in the time period she is bred (1)
  mutate(
    bred_status = ifelse(any(event == "BRED" & !is.na(event) & event != ""), 1, 0)
  ) %>%
  ungroup()

# carry down pregnant status 
animals_repro <- animals_repro %>%
  group_by(id_animal_lact) %>%  # Process per animal
  arrange(id_animal_lact, period_start_date) %>%  # Ensure data is sorted by period
  mutate(
    # If there's an ABORT event, set pregnant_status to 0 immediately
    pregnant_status = case_when(
      event == "ABORT" ~ "0",  # Reset to 0 if there's an ABORT event

      # If pregnant_status is NA or 0 and previous row had pregnant_status == 1, carry it down
      (is.na(pregnant_status) | pregnant_status == "0") & lag(pregnant_status, default = "0") == "1" ~ "1",  # Carry down pregnancy status

      # If date_fresh happens during this period, set pregnant_status to 0
      !is.na(date_fresh) & date_fresh >= period_start_date & date_fresh <= period_end_date ~ "0",

      # Default case: keep existing pregnant_status if none of the above apply
      TRUE ~ as.character(pregnant_status)
    )
  ) %>%
  # Fill down pregnant_status for all rows in each animal group
  fill(pregnant_status, .direction = "down") %>%
  ungroup()


# convert binary to numeric for later use
animals_repro <- animals_repro %>%
  mutate(
    bred_status = as.numeric(bred_status),
    pregnant_status = as.numeric(pregnant_status),  
    vwp_status = as.numeric(vwp_status)  
  )

eligible_cows <- animals_repro %>%
  # Filter cows that are after VWP and not pregnant
  filter(vwp_status == 1, pregnant_status == 0) %>%
  group_by(id_animal_lact) %>%
  arrange(id_animal_lact, period_start_date) %>%
  mutate(
    # Set eligibility_status based on the conditions
    eligibility_status = case_when(
      event == "DNB" ~ 0,  # DNB event sets eligibility_status to 0
      !is.na(date_archive) &
        date_archive >= period_start_date &
        date_archive <= period_end_date + 60 ~ 0,  # Date archive within period or 60 days after end sets eligibility_status to 0
      vwp_status == 1 & pregnant_status == 0 ~ 1,  # Both vwp_status = 1 and pregnant_status = 0 set eligibility_status to 1
      TRUE ~ 0  # Default to 0
    )
  ) %>%
  # Propagate eligibility_status = 0 for subsequent rows if eligibility_status is 0 in the previous row
  mutate(
    eligibility_status = if_else(
      cumsum(eligibility_status == 0) > 0, 0, eligibility_status  # Propagate 0 forward based on cumulative sum of previous 0s
    )
  ) %>%
  ungroup()


#Create eligibility data set that only has one entry per cow per period with eligibiity status
eligible_cows <- eligible_cows %>% 
  filter(eligibility_status == 1) %>%
  select(id_animal_lact, period_number, period_start_date, period_end_date, eligibility_status) %>%
  group_by(id_animal_lact, period_number) %>%
  mutate(
    eligibility_status = if_else(all(eligibility_status == 1), 1, 0)
  ) %>%
  distinct(id_animal_lact, period_number, .keep_all = TRUE) %>%
  ungroup()

# Create eligibility Table
eligible_cows_summary <- eligible_cows %>%
  filter(eligibility_status == 1) %>%
  mutate(lact_number = sub(".*_(\\d+)$", "\\1", id_animal_lact)) %>%  # Extract lact_number from id_animal_lact
  group_by(period_number, lact_number) %>%
  summarise(total_eligible_cows = n(), .groups = "drop") %>%
  pivot_wider(names_from = lact_number, values_from = total_eligible_cows, values_fill = list(total_eligible_cows = 0)) %>%
  mutate(total = rowSums(select(., -period_number), na.rm = TRUE))  # Add total column

animals_repro <- animals_repro %>% 
  arrange(id_animal_lact, period_start_date)

#      *Number Pregnant Logic:*

# need number of bred_events in repro_data that resulted in pregnancy, dynamically

# Count the number of breedings that resulted in a pregnancy per period and lactation group
pregnant_counts_by_period <- animals_repro %>%
  filter(event == "BRED" & R %in% c("P", "A", "C")) %>%  # Only include breedings that resulted in pregnancy
  mutate(lact_number = sub(".*_(\\d+)$", "\\1", id_animal_lact)) %>%  # Extract lact_number from id_animal_lact
  group_by(period_number, lact_number) %>%  # Group by period_number and lactation group
  summarise(total_pregnancies = n(), .groups = "drop")  # Count pregnancies per period and lactation group

# Pivot the table to get lactation number as columns and total pregnancies as values
pregnant_counts_table <- pregnant_counts_by_period %>%
  pivot_wider(names_from = lact_number, values_from = total_pregnancies, values_fill = list(total_pregnancies = 0)) %>%  # Pivot to wide format
  mutate(Total = rowSums(across()))  # Calculate total pregnancies across lactation groups  

# Preg Risk Table
eligible_cows_summary_trimmed <- eligible_cows_summary %>%
  slice(1:(n() - 2))

preg_risk_table <- pregnant_counts_table / eligible_cows_summary_trimmed


preg_risk_table <- preg_risk_table %>%
  mutate(across(where(is.numeric), 
                ~ ifelse(is.na(.), "0%", paste0(round(.*100, 1), "%"))))
```

```{r}
# conception rate over time
```

# Lameness

```{r}
# Lameness events by DIM

graph <- ggplot(lame_data, aes(x = dim_event)) +
  geom_histogram(binwidth = 10, fill = "steelblue", color = "black", alpha = 0.7) +
  theme_minimal(base_size = 14) +
  facet_wrap(vars(event), ncol = 1, scales = "free") +
  labs(
    title = "Distribution of Lameness Events Over Days in Milk",
    x = "Days in Milk",
    y = "Count"
  ) +
  theme(
    panel.grid.major = element_line(color = "gray80"),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  )

print(graph)
```

```{r}
#| fig-height: 8

summarize_lame_events<-lame_data |> 
  group_by(event, protocols_remaining_after_numbers1) |> 
  summarize(count_rows=sum(n()))|>
  ungroup()%>%
  mutate(event_type = factor(protocols_remaining_after_numbers1), 
         Event = factor(event),
         event_type = if_else(is.na(event_type), "Trim Only", event_type))

facet_order <- summarize_lame_events %>%
  group_by(event_type) %>%
  summarise(n_y = n_distinct(event)) %>%
  arrange(desc(n_y)) %>%  # Order by most y categories
  pull(event_type)

# order events
summarize_lame_events <- summarize_lame_events %>%
  mutate(event_type = fct_reorder(event_type, count_rows, .fun = sum, .desc = FALSE)) 

  ggplot(summarize_lame_events)+
  geom_bar(aes(x = event_type,
               y = count_rows, fill = event_type), stat = "identity")+
  #facet_wrap(factor(event, levels = facet_order) ~., scales = 'free')+
    facet_wrap(vars(event), ncol = 1, scales = "free")+
  coord_flip()+
  scale_fill_viridis_d()+
  theme_minimal()+
  labs(x = "",
       y = "Row Count")+
  theme(legend.position = "none",
        # axis.text.y = element_text(size = 6)
  )
```

```{r}
# Lameness events by DIM and event type
library(dplyr)
library(ggplot2)
library(viridis)

# Summarize data
summarized_lame_events <- lame_data |> 
  group_by(dim_event, event, protocols_remaining_after_numbers1) |> 
  summarise(count_rows = n(), .groups = "drop") |> 
  mutate(event_type = factor(protocols_remaining_after_numbers1),
         event = factor(event),
         event_type = if_else(is.na(event_type), "Trim Only", event_type))

# Identify the top 5 most frequent event types
top_5_events <- summarized_lame_events |> 
  group_by(event_type) |> 
  summarise(total_count = sum(count_rows)) |> 
  arrange(desc(total_count)) |> 
  slice_head(n = 5) |> 
  pull(event_type)

# Filter dataset to include only top 5 event types
summarized_lame_events <- summarized_lame_events |> 
  filter(event_type %in% top_5_events)

# Plot stacked bar graph with 30-day tick marks on x-axis
ggplot(summarized_lame_events, aes(x = dim_event, y = count_rows, fill = event_type)) +
  geom_col(width = 14, position = "stack") +  # Use geom_col for numeric x-axis
  scale_fill_viridis_d() +  # Colorblind-friendly palette
  scale_x_continuous(breaks = seq(0, max(summarized_lame_events$dim_event), by = 60)) +  # Tick marks every 30 days
  theme_minimal(base_size = 14) +
  facet_wrap(vars(event), ncol = 1, scales = "free_y") +  # Separate facets for each event
  labs(
    title = "Stacked Bar Graph of Lameness Events by Days in Milk",
    x = "Days in Milk",
    y = "Count of Events",
    fill = "Event Type"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
    panel.grid.major = element_line(color = "gray80", size = 0.3),  # Thinner grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    strip.text = element_text(size = 14, face = "bold"),
    legend.position = "right"
  )

```

# Mastitis

```{r}



graph <- ggplot(mastitis_data, aes(x = dim_event)) +
  geom_histogram(binwidth = 10, fill = "steelblue", color = "black", alpha = 0.7) +
  theme_minimal(base_size = 14) +
  facet_wrap(vars(event), ncol = 1, scales = "free") +
  labs(
    title = "Distribution of Mastitis Events Over Days in Milk",
    x = "Days in Milk",
    y = "Count"
  ) +
  theme(
    panel.grid.major = element_line(color = "gray80"),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  )

print(graph)
```
