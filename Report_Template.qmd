---
title: "Report_Template"
editor: source
format: 
 html:
   embed-resources: true
   toc: true
   toc-location: left
execute:
    echo: false
    message: false
    warning: false
---

```{r}
library(tidyverse)
library(arrow)
library(dtplyr)
library(DT)
library(survival)
library(survminer)
library(stringr)
library(viridis)
library(RColorBrewer)
library(flextable)
library(officer)
library(gtsummary)
library(cardx)
library(htmltools)
library(lubridate)
library(httr)
library(jsonlite)
library(gt)
library(scales)

# Initialization and organization of initial data sets

source('functions/DT_base.R') #functions to parse remarks and protocols

# Intialize animal and animal lactation file and assign data pull date to an object for later use.
animals <- read_parquet('data/intermediate_files/animals.parquet')

animal_lactations<-read_parquet('data/intermediate_files/animal_lactations.parquet') 

pull_date <- unique(animals$data_pull_date_max)

date_start <- pull_date - 365 # pulls last year of data, modify for specific project

events_formatted <-read_parquet('data/intermediate_files/events_formatted.parquet')

# Pull the wanted information into a new data sets (double check in DC that the events are actually being recorded under these event names)

# Mastitis
mastitis_data <- events_formatted %>%
  filter(event %in% c("MAST"))

# Lameness
lame_data <- events_formatted %>%
  filter(event %in% c("LAME"))

# Reroduction
repro_data <- events_formatted %>%
  filter(event_type %in% c("repro"))%>%
  select(id_animal, id_animal_lact, date_birth, lact_number, event, date_event, dim_event, R)

vwp <- 50 # Set to herd's VWP

# Youngstock
youngstock_data <- events_formatted%>%
  filter(lact_number == 0)

# Pull production data from dairy comp and re-format:
# EVENTS ID BDAT LACT\4S730 (730 = last 2 years of data, change based on goals)
# Save in data/intermediate_files/production_data. It should be the only file in there

# Define file path
# production_file <- "data/intermediate_files/production_data/production.parquet"
# 
# # Read Parquet file
# production_data <- read_parquet(production_file)
# 
# # Reformat the data
# production_data <- production_data %>%
#   mutate(
#     id_animal = paste0(as.character(ID), "_", as.character(BDAT)) #Create id_animal
#   ) %>%
#   rename(id = ID) %>%  
#   rename(date_birth = BDAT)%>%
#   rename(date_test = TestDate) %>%  
#   mutate(date_test = mdy(date_test))%>% # Convert to Date (Adjust format if needed)
#   relocate(id_animal, .before = everything())  # Move id_animal to the first column
# 


```

```{r}
#Create denominators

# Define date range
#date_start previously defined as pull_date - 365
date_end <- pull_date
date_start_month <- floor_date(date_start, "month") # set to first day of month for monthly calculations later
date_end_month <- floor_date(pull_date, "month") %m+% months(1) - days(1) # set to last day of month for monthly calculations later


filtered_animals <- animal_lactations |>
  mutate(year_fresh = year(date_fresh)) |>  # Find freshening year
  filter(lact_number > 0) |>  # Keep only lactating cows
  filter(date_archive <= date_end | is.na(date_archive)) |> # Ask about this?
  filter(date_fresh<= date_start & date_archive_max >= date_start |
           date_fresh<= date_start & is.na(date_archive_max) |
           date_fresh >= date_start & date_archive_max <= date_end|
           date_fresh >= date_start & is.na(date_archive_max))

# Summarize total active cows (unique count per year)
total_cows <- filtered_animals |> 
  group_by(year_fresh, id_animal) |> 
  slice_tail() |>  # Ensure unique count per cow
  ungroup() |> 
  group_by(year_fresh) |> 
  summarise(cows_total = n()) |>  # Get total cows
  mutate(lact_group = "Total")

# Summarize by lactation group (lact_number)
summary_lact <- filtered_animals |> 
  group_by(year_fresh, lact_number) |> 
  summarize(count_animals = n_distinct(id_animal)) |>  # Count cows in each lactation group
  ungroup() |> 
  mutate(lact_number = ifelse(is.na(lact_number), "Total", lact_number))  # Replace NA with "Total"

# Combine both summary datasets
summary_lact_final <- bind_rows(total_cows, summary_lact) |> 
  group_by(lact_number) |> 
  summarise(
    total_animals_by_lact = sum(count_animals, na.rm = TRUE))|> 
  ungroup()

#                             Monthly Calculations:
# Generate a list of all months in the date range
months_list <- seq(date_start_month, date_end_month, by = "month") |> format("%Y-%m")

# Define a function to calculate monthly active cows by lactation group
count_active_by_month <- function(month, filtered_animals) {
  # Define the start and end date for this month
  month_start <- ymd(paste0(month, "-01"))
  month_end <- ceiling_date(month_start, "month") - days(1)
  
  # Filter animals that were active in this month
  active_animals <- filtered_animals |> 
    filter(
      # Check if the cow was active in this month
      (date_fresh<= month_start & date_archive_max >= month_start |
           date_fresh<= month_start & is.na(date_archive_max) |
           date_fresh >= month_start & date_archive_max <= month_end|
           date_fresh >= month_start & is.na(date_archive_max)))
    
  # Count the cows in each lactation group for this month
  active_counts <- active_animals |> 
    group_by(lact_number) |> 
    summarise(cows_active = n(), .groups = "drop") |> 
    spread(key = lact_number, value = cows_active, fill = 0)
  
  # Add the month column
  active_counts$month <- month
  
  # Add total_monthly column by summing across the row (excluding the 'month' column)
  active_counts <- active_counts |> 
    mutate(total_monthly = rowSums(active_counts[, -which(names(active_counts) == "month")], na.rm = TRUE))
  
  return(active_counts)
}

# Apply the function to each month in the date range
monthly_data <- purrr::map_dfr(months_list, count_active_by_month, filtered_animals = filtered_animals)

# Reformat the month to the desired format
monthly_data <- monthly_data |> 
  mutate(month = format(ymd(paste0(month, "-01")), "%b-%y")) |>  # Reformat the month column

  # Ensure month is the first column
  select(month, everything())

```

# Herd Summary

Herd Demographics:

```{r}
# Create the table from monthly_data
monthly_table <- monthly_data |> 
  gt() |> 
  tab_header(
    title = "Monthly Active Cows by Lactation Group",
    subtitle = "Number of active cows per lactation group each month"
  ) |> 
  cols_label(
    month = "Month",  # Clean up the month column label
    total_monthly = "Total"
  ) |> 
  fmt_number(
    columns = starts_with("lact_number"),  # Format numbers in lactation group columns
    decimals = 0
  ) |> 
  tab_spanner(
    label = "Lactation Groups",
    columns = starts_with("lact_number")  # Spanner for lactation group columns
  ) |> 
  tab_style(
    style = cell_text(weight = "bold", size = "large"),  # Bold and larger text for headers
    locations = cells_column_labels()
  ) |> 
  tab_style(
    style = cell_text(weight = "bold"),  # Bold the 'month' column for emphasis
    locations = cells_column_labels(columns = vars(month))
  ) |> 
  tab_style(
    style = cell_fill(color = "lightgray"),  # Light gray background for the headers
    locations = cells_column_labels()
  ) |> 
  tab_style(
    style = cell_fill(color = "#f7f7f7"),  # Light fill for every alternate row for better readability
    locations = cells_body(rows = seq(1, nrow(monthly_data), by = 2))
  ) |> 
  tab_style(
    style = cell_text(align = "right"),  # Right-align the numbers in the lactation group columns
    locations = cells_body(columns = starts_with("lact_number"))
  ) |> 
  tab_style(
    style = cell_text(align = "center"),  # Center-align the 'month' column
    locations = cells_body(columns = vars(month))
  ) |> 
  tab_options(
    table.border.top.width = px(2),  # Border above the table
    table.border.bottom.width = px(2),  # Border below the table
    table.font.size = 12  # Font size for table
  )

# Print the table
monthly_table

```

```{r}

# Remove the total_monthly column
monthly_data_cleaned <- monthly_data |> 
  select(-total_monthly)

# Create a separate dataset for 'total_monthly' for plotting
total_monthly_data <- monthly_data |> 
  select(month, total_monthly) |> 
  pivot_longer(cols = total_monthly, names_to = "lactation", values_to = "cows_active") |> 
  mutate(lactation = "Total")  # Label this as 'Total' for the plot

# Now proceed with pivoting and transforming the rest of the data
monthly_data_long <- monthly_data_cleaned |> 
  pivot_longer(cols = -c(month), names_to = "lactation", values_to = "cows_active") |> 
  mutate(
    lactation = ifelse(lactation %in% c("1", "2"), lactation, "3+")  # Condense lactation 3+ into "3+"
  ) |> 
  group_by(month, lactation) |>  # Group by month and lactation
  summarise(cows_active = sum(cows_active), .groups = "drop")  # Aggregate by month and lactation

# Combine the 'monthly_data_long' and 'total_monthly_data'
combined_data <- bind_rows(monthly_data_long, total_monthly_data)

# Convert Month to date format for plot
combined_data <- combined_data |> 
  mutate(month = as.Date(parse_date_time(month, orders = "my")))  

ggplot(combined_data, aes(x = month, y = cows_active, color = lactation, group = lactation)) +
  geom_line(size = 1.2) +  
  geom_point(size = 4, shape = 21, fill = "white", stroke = 1.5) +  
  labs(
    title = "Monthly Lactating Herd by Lactation Number and Total",
    x = "Month",
    y = "Number of Active Cows",
    color = "Lactation Group"
  ) +
  scale_x_date(date_labels = "%b %Y", date_breaks = "1 month") +  # Ensure correct order
  theme_minimal() +  
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  
    plot.title = element_text(size = 16, face = "bold"),  
    axis.title = element_text(size = 14),  
    legend.title = element_text(size = 12),  
    legend.text = element_text(size = 10),  
    panel.grid.major = element_line(color = "gray90", size = 0.5),  
    panel.grid.minor = element_blank()  
  )

```

```{r}
# Milk production by month overtime:

# Filter only test data within our date range
production_data <- production_data |>
  filter(date_test > date_start)

# Remove * from Milk and convert to numeric
monthly_data <- production_data %>%
  mutate(MILK = as.numeric(gsub("\\*", "", MILK)))

# Collect monthly averages
monthly_data <- monthly_data %>%
  mutate(month = floor_date(date_test, "month")) %>%
  group_by(month) %>%
  summarize(avg_milk = mean(MILK, na.rm = TRUE))

# Identify the most recent month
most_recent_month <- max(monthly_data$month, na.rm = TRUE)

# Filter out the most recent month
monthly_data <- monthly_data %>%
  filter(month != most_recent_month)

# Find the lowest points for labeling
lowest_points <- monthly_data %>%
  filter(avg_milk == min(avg_milk, na.rm = TRUE))  # Find the lowest average milk points

# Plot
ggplot(monthly_data, aes(x = month, y = avg_milk)) +
  geom_line(color = "#2C3E50", size = 1.2) +  # Line color and size
  geom_point(aes(color = avg_milk), size = 3) +  # Point size and coloring
  geom_text(data = lowest_points, aes(label = paste0(round(avg_milk, 2))),
            vjust = -1, hjust = 0.5, color = "red", size = 4) +  # Labels for lowest points
  
  # Add additional labels for specific months 
  geom_text(aes(label = ifelse(month %in% seq(min(month), max(month), by = "3 months"), 
                               format(month, "%b %Y"), "")),
            vjust = 1.5, size = 3, color = "#2980B9", angle = 45, hjust = 0.5) +  # Labels for key months
  
  geom_smooth(method = "loess", se = FALSE, color = "green", size = 1) +  # Smoothing line
  
  # Formatting
  scale_x_date(date_labels = "%b %Y", date_breaks = "3 months") +  # Date labels
  labs(title = "Average Monthly Milk Production",
       subtitle = "Trends and key points of milk production over time",
       x = "Month",
       y = "Average Milk Production (L)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
        plot.title = element_text(face = "bold", size = 16),  # Bold title
        plot.subtitle = element_text(size = 12),  # Subtitle size
        axis.title = element_text(size = 14))  # Axis titles size

```

```{r}
# Plot THI over Weekly Milk prodcution

# Pull weather data from VisualConnections API. You need an API key saved as an environmental variable in your computer

get_weather_data <- function(location, date_range = "lastyear", api_key = NULL) {
  if (is.null(api_key) || api_key == "") {
    message("API key is missing, skipping weather data retrieval.")
    return(NULL)  # Return NULL if no API key is found
  }
  
  url <- paste0("https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/",
                location, "/", date_range, "?unitGroup=us&key=", api_key)
  
  response <- GET(url)
  
  if (status_code(response) == 200) {
    data <- content(response, "text", encoding = "UTF-8")
    weather_data <- fromJSON(data)
    return(weather_data)
  } else {
    stop("Request failed")
  }
}

# Example usage
location <- "55350"  # Zip code for the location
date_range <- "lastyear"  # Use 'lastyear' to pull data from the last year

# Check for the API key in environment variables
api_key <- Sys.getenv("VISUAL_CROSSING_API_KEY")

# Get weather data only if the API key is available
weather_data_raw <- if (!is.null(api_key) && api_key != "") {
  get_weather_data(location, date_range, api_key)
} else {
  NULL  # If API key is missing, skip fetching weather data
}

# If weather data was successfully retrieved, process it
if (!is.null(weather_data_raw)) {
  
  # Convert the weather data (assuming it is under 'days')
  weather_data_raw <- as.data.frame(weather_data_raw$days)

  # Select relevant columns and convert the 'date' column to Date format
  weather_data <- weather_data_raw %>%
    select(datetime, temp, humidity) %>%
    mutate(datetime = as.Date(datetime))%>%
    rename(date_weather = datetime)%>%
    mutate(THI = temp - (0.55 - 0.0055 * humidity) * (temp - 58)) 
  
  weather_data <- weather_data%>%
    filter(date_weather >= date_start & date_weather <= date_end)
  
  # Weekly THI Averages:
  # Group the weather data by week and calculate the weekly average THI
  weather_weekly <- weather_data %>%
    mutate(date_weather = floor_date(date_weather, "week")) %>%
    group_by(date_weather) %>%
    summarize(avg_THI = mean(THI, na.rm = TRUE))

  # color scale
  weather_weekly <- weather_weekly %>%
    mutate(THI_color = case_when(
      avg_THI >= 70 ~ "red",       
      avg_THI >= 60 ~ "orange",    
      avg_THI >= 50 ~ "yellow",    
      TRUE ~ "green"           
    ))
  
  weather_weekly <- weather_weekly %>%
    mutate(next_date = lead(date_weather),   # Get the next date for each row (for segment plotting)
           next_THI = lead(avg_THI),     # Get the next THI value for each row
           next_THI_color = lead(THI_color))  # Get the next THI color
  
  # Plot with color-changing line
  thi_plot <- ggplot(weather_weekly, aes(x = date_weather, y = avg_THI)) +
    geom_segment(aes(xend = next_date, yend = next_THI, color = next_THI_color), size = 1) +  # Line segments with color
    labs(title = "Thermal Heat Index (THI) Over Time",
         x = "Date",
         y = "THI") +
    scale_color_identity() +  # Use color values directly from the THI_color column
    theme_minimal() +  # Minimal theme for a clean look
    theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels
   
}

# Filter production data to get weekly averages for past year:

milk_weekly <- production_data %>%
  mutate(MILK = as.numeric(gsub("\\*", "", MILK)))

milk_weekly <- milk_weekly %>%
  mutate(week = floor_date(date_test, "week")) %>%
  group_by(week) %>%
  summarize(avg_milk = mean(MILK, na.rm = TRUE))

# Filter for the last 12 months
milk_weekly_last_year <- milk_weekly %>%
  filter(week >= date_start)

milk_plot <- ggplot(milk_weekly_last_year, aes(x = week, y = avg_milk)) +
  geom_line(color = "green", size = 1) +  # Line for milk production
  labs(title = "THI and Weekly Average Milk Production Over the Last Year",
       x = "Date",
       y = "Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

combined_plot <- ggplot() + 
  # Plot the THI data with color-changing line segments
  geom_segment(data = weather_weekly, 
               aes(x = date_weather, y = avg_THI, xend = next_date, yend = next_THI, color = next_THI_color), 
               size = 1.2) +  # Slightly thicker line for better visibility
  # Plot the Milk Production as a line plot
  geom_line(data = milk_weekly_last_year, aes(x = week, y = avg_milk), color = "steelblue", size = 1.2) +
  
  # Add points on the milk production line for better visual tracking
  geom_point(data = milk_weekly_last_year, aes(x = week, y = avg_milk), color = "steelblue", size = 2) +
  
  # Add titles and labels
  labs(
    title = "THI and Weekly Average Milk Production Over the Last Year",
    subtitle = "Weekly averages of milk production and Thermal Heat Index",
    x = "Week",
    y = "THI",
    caption = "Data Source: VisualCrossing API"
  ) +
  
  # Enhance the color scale for THI levels
  scale_color_manual(values = c("green", "yellow", "orange", "red"),
                     breaks = c("green", "yellow", "orange", "red"),
                     labels = c("Low THI (< 50)", "Moderate THI (50-60)", "High THI (60-70)", "Very High THI (> 70)")) +
  
  # Modify gridlines and background for clarity
  theme_minimal(base_size = 14) +  # Increase base size for readability
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 12),  # Rotate x-axis labels for readability
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 12, face = "italic"),
    plot.caption = element_text(hjust = 1, size = 10, color = "gray"),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 11)
  ) +
  
  # Secondary y-axis for milk production
  scale_y_continuous(
    name = "THI", 
    sec.axis = sec_axis(~ ., name = "Milk Production (units)")
  ) +  # You can adjust scaling between THI and Milk Production if necessary
  
  theme(
    axis.title.y.right = element_text(color = "black", size = 14),
    axis.text.y.right = element_text(color = "black", size = 12),
    legend.position = "top"  # Position the legend at the top
  )

# Show the plot
print(combined_plot)

```

# Reproduction - TBD

```{r}
# 21 Day Preg Risk
date_end <- pull_date

# Create periods (21-day intervals)
periods <- seq(date_start, date_end, by = "21 days")

# Ensure lact_number > 0 and only repro events that affect elig.
repro_data <- repro_data %>%
  filter(lact_number > 0, event %in% c("PREG", "ABORT", "BRED", "OK", "OPEN", "DNB"))

# Assign time periods to repro data
repro_data <- repro_data %>%
  mutate(
    period_number = findInterval(date_event, periods, rightmost.closed = TRUE),
    period_start_date = periods[pmax(period_number, 1)],  # Assign start date
    period_end_date = period_start_date + 20,  # 21-day period
    period_end_date = case_when(
      period_end_date > date_end ~ date_end,  # Reset if > date_end
      TRUE ~ period_end_date  # Otherwise, keep the calculated end date
    )
  )

# set up animal data
animals_repro <- animal_lactations %>% 
  filter(lact_number > 0) %>%
  filter(lact_number != 32) |> 
  filter(date_archive >= date_start | is.na(date_archive)) %>% 
  select(id_animal_lact, date_fresh, date_archive) 

# Create row for every animal in every period
all_periods <- animals_repro %>%
  distinct(id_animal_lact) %>%  # Get unique id_animal_lact
  mutate(id_animal_lact = as.character(id_animal_lact)) %>%  # Ensure it's character type for joining
  crossing(period_start_date = periods) %>%  # Cross join with periods to get 18 rows per id_animal_lact
  mutate(
    period_end_date = period_start_date + 20,  # Assign 21-day period
    period_number = match(period_start_date, periods)  # Assign period number based on periods vector
  )

# Merge with existing animal_repro data
animals_repro <- all_periods %>%
  left_join(animals_repro, by = c("id_animal_lact")) %>%
  group_by(id_animal_lact) %>%
  fill(date_fresh, date_archive, .direction = "downup") %>%  # Ensure lact info is copied
  ungroup()

# Ensure data is sorted by animal and period
animals_repro <- animals_repro %>%
  arrange(id_animal_lact, period_start_date) %>% 
  mutate(date_vwp = date_fresh + vwp)

# set up event data 
events_filtered <- events_formatted %>%
  filter(event %in% c("PREG", "ABORT"))

# Set up event data with period information (matching the structure of animals_repro)
events_filtered <- events_filtered %>%
  # Ensure the correct period info is in the events data by matching on period numbers
  left_join(
    animals_repro %>%
      select(id_animal_lact, period_number, period_start_date, period_end_date),
    by = c("id_animal_lact")
  ) 

events_filtered <- events_filtered %>%
  filter(date_archived > date_start | is.na(date_archived))

# Get the latest PREG and ABORT event before each period_start_date
latest_preg_events <- events_filtered %>%
  filter(event == "PREG") %>%  # Keep only the PREG events
  group_by(id_animal_lact, period_start_date) %>%
  slice_max(date_event, n = 1) %>%  # Get the most recent PREG event
  rename(latest_preg_event = date_event) %>%  # Rename the date column
  ungroup()

# Get the most recent ABORT event for each animal in each period
latest_abort_events <- events_filtered %>%
  filter(event == "ABORT") %>%  # Keep only the ABORT events
  group_by(id_animal_lact, period_start_date) %>%
  slice_max(date_event, n = 1) %>%  # Get the most recent ABORT event
  rename(latest_abort_event = date_event) %>%  # Rename the date column
  ungroup()

latest_events <- latest_preg_events %>%
  left_join(
    latest_abort_events %>% select(id_animal_lact, period_start_date, latest_abort_event),  # Only keep relevant columns from latest_abort_events
    by = c("id_animal_lact", "period_start_date")
  )




# Merge the latest PREG and ABORT event dates back into animals_repro
animals_repro <- animals_repro %>%
  left_join(
    latest_events %>%
      select(id_animal_lact, period_number, latest_preg_event, latest_abort_event),  # Only keep the relevant columns
    by = c("id_animal_lact", "period_number")  # Match on id_animal_lact and period_number
  )

# Merge data - assign events to animal and period
animals_repro <- animals_repro %>%
  left_join(
    repro_data %>% 
      select(id_animal_lact, period_start_date, event, R, 
             period_number, period_end_date), 
    by = c("id_animal_lact", "period_start_date", "period_end_date", "period_number")
  )

# Pregnancy status based on the latest events
animals_repro <- animals_repro %>%
  mutate(
    pregnant_status = case_when(
      # If the event is "PREG", set pregnant_status to 1
      event == "PREG" ~ "1",
      # If there is an abort event that is after the last preg event and the last        abort date is before the end of the period, she is not pregnant
      !is.na(latest_abort_event) & latest_abort_event > latest_preg_event & latest_abort_event <= period_start_date ~ "0",
      # If there is a fresh date and the fresh date is after the last preg event         date and the fresh date is before the period start date, she is not pregnant
      !is.na(date_fresh) & date_fresh > latest_preg_event & date_fresh <= period_start_date ~ "0", 
      # If there is a valid preg date and there is no abort date or the last abort         date is before the preg date and there is no fresh date or the fresh date          is before the preg date then she is pregnant
      !is.na(latest_preg_event) & (is.na(latest_abort_event) | latest_abort_event < latest_preg_event | latest_abort_event > period_end_date) &
        (is.na(date_fresh) | date_fresh < latest_preg_event) ~ "1",
      # For any animals that do not meet the criteria listed above, they are listed       as not pregnant
      TRUE ~ "0"
    )
  )

animals_repro <- animals_repro %>%
  mutate(
    date_vwp = as.Date(date_vwp),
    period_start_date = as.Date(period_start_date),
    period_end_date = as.Date(period_end_date)
  )

# VWP logic, if VWP date is < period end date than eligible at some point in period so assign 1
animals_repro <- animals_repro %>%
  mutate(
    vwp_status = case_when(
      is.na(date_vwp) ~ NA_real_,  # If date_vwp is NA, return NA (you can change this to any default value you want)
      date_vwp <= period_end_date ~ 1,
      date_vwp > period_end_date ~ 0,
      TRUE ~ NA_real_  # You can handle any edge cases if necessary
    )
  )

animals_repro <- animals_repro %>% 
  group_by(id_animal_lact, period_end_date) %>%
  # if there is a bred event in the time period she is bred (1)
  mutate(
    bred_status = ifelse(any(event == "BRED" & !is.na(event) & event != ""), 1, 0)
  ) %>%
  ungroup()

# carry down pregnant status 
animals_repro <- animals_repro %>%
  group_by(id_animal_lact) %>%  # Process per animal
  arrange(id_animal_lact, period_start_date) %>%  # Ensure data is sorted by period
  mutate(
    # If there's an ABORT event, set pregnant_status to 0 immediately
    pregnant_status = case_when(
      event == "ABORT" ~ "0",  # Reset to 0 if there's an ABORT event

      # If pregnant_status is NA or 0 and previous row had pregnant_status == 1, carry it down
      (is.na(pregnant_status) | pregnant_status == "0") & lag(pregnant_status, default = "0") == "1" ~ "1",  # Carry down pregnancy status

      # If date_fresh happens during this period, set pregnant_status to 0
      !is.na(date_fresh) & date_fresh >= period_start_date & date_fresh <= period_end_date ~ "0",

      # Default case: keep existing pregnant_status if none of the above apply
      TRUE ~ as.character(pregnant_status)
    )
  ) %>%
  # Fill down pregnant_status for all rows in each animal group
  fill(pregnant_status, .direction = "down") %>%
  ungroup()


# convert binary to numeric for later use
animals_repro <- animals_repro %>%
  mutate(
    bred_status = as.numeric(bred_status),
    pregnant_status = as.numeric(pregnant_status),  
    vwp_status = as.numeric(vwp_status)  
  )

eligible_cows <- animals_repro %>%
  # Filter cows that are after VWP and not pregnant
  filter(vwp_status == 1, pregnant_status == 0) %>%
  group_by(id_animal_lact) %>%
  arrange(id_animal_lact, period_start_date) %>%
  mutate(
    # Set eligibility_status based on the conditions
    eligibility_status = case_when(
      event == "DNB" ~ 0,  # DNB event sets eligibility_status to 0
      !is.na(date_archive) &
        date_archive >= period_start_date &
        date_archive <= period_end_date + 60 ~ 0,  # Date archive within period or 60 days after end sets eligibility_status to 0
      vwp_status == 1 & pregnant_status == 0 ~ 1,  # Both vwp_status = 1 and pregnant_status = 0 set eligibility_status to 1
      TRUE ~ 0  # Default to 0
    )
  ) %>%
  # Propagate eligibility_status = 0 for subsequent rows if eligibility_status is 0 in the previous row
  mutate(
    eligibility_status = if_else(
      cumsum(eligibility_status == 0) > 0, 0, eligibility_status  # Propagate 0 forward based on cumulative sum of previous 0s
    )
  ) %>%
  ungroup()


#Create eligibility data set that only has one entry per cow per period with eligibiity status
eligible_cows <- eligible_cows %>% 
  filter(eligibility_status == 1) %>%
  select(id_animal_lact, period_number, period_start_date, period_end_date, eligibility_status) %>%
  group_by(id_animal_lact, period_number) %>%
  mutate(
    eligibility_status = if_else(all(eligibility_status == 1), 1, 0)
  ) %>%
  distinct(id_animal_lact, period_number, .keep_all = TRUE) %>%
  ungroup()

# Create eligibility Table
eligible_cows_summary <- eligible_cows %>%
  filter(eligibility_status == 1) %>%
  mutate(lact_number = sub(".*_(\\d+)$", "\\1", id_animal_lact)) %>%  # Extract lact_number from id_animal_lact
  group_by(period_number, lact_number) %>%
  summarise(total_eligible_cows = n(), .groups = "drop") %>%
  pivot_wider(names_from = lact_number, values_from = total_eligible_cows, values_fill = list(total_eligible_cows = 0)) %>%
  mutate(total = rowSums(select(., -period_number), na.rm = TRUE))  # Add total column

animals_repro <- animals_repro %>% 
  arrange(id_animal_lact, period_start_date)

#      *Number Pregnant Logic:*

# need number of bred_events in repro_data that resulted in pregnancy, dynamically

# Count the number of breedings that resulted in a pregnancy per period and lactation group
pregnant_counts_by_period <- animals_repro %>%
  filter(event == "BRED" & R %in% c("P", "A", "C")) %>%  # Only include breedings that resulted in pregnancy
  mutate(lact_number = sub(".*_(\\d+)$", "\\1", id_animal_lact)) %>%  # Extract lact_number from id_animal_lact
  group_by(period_number, lact_number) %>%  # Group by period_number and lactation group
  summarise(total_pregnancies = n(), .groups = "drop")  # Count pregnancies per period and lactation group

# Pivot the table to get lactation number as columns and total pregnancies as values
pregnant_counts_table <- pregnant_counts_by_period %>%
  pivot_wider(names_from = lact_number, values_from = total_pregnancies, values_fill = list(total_pregnancies = 0)) %>%  # Pivot to wide format
  mutate(Total = rowSums(across()))  # Calculate total pregnancies across lactation groups  

# Preg Risk Table
eligible_cows_summary_trimmed <- eligible_cows_summary %>%
  slice(1:(n() - 2))

preg_risk_table <- pregnant_counts_table / eligible_cows_summary_trimmed


preg_risk_table <- preg_risk_table %>%
  mutate(across(where(is.numeric), 
                ~ ifelse(is.na(.), "0%", paste0(round(.*100, 1), "%"))))
```

```{r}
# conception rate over time
```

# Lameness

```{r}
# Lameness events by DIM

graph <- ggplot(lame_data, aes(x = dim_event)) +
  geom_histogram(binwidth = 10, fill = "steelblue", color = "black", alpha = 0.7) +
  theme_minimal(base_size = 14) +
  facet_wrap(vars(event), ncol = 1, scales = "free") +
  labs(
    title = "Distribution of Lameness Events Over Days in Milk",
    x = "Days in Milk",
    y = "Count"
  ) +
  theme(
    panel.grid.major = element_line(color = "gray80"),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  )

print(graph)
```

```{r}
#| fig-height: 8

summarize_lame_events<-lame_data |> 
  group_by(event, protocols_remaining_after_numbers1) |> 
  summarize(count_rows=sum(n()))|>
  ungroup()%>%
  mutate(event_type = factor(protocols_remaining_after_numbers1), 
         Event = factor(event),
         event_type = if_else(is.na(event_type), "Trim Only", event_type))

facet_order <- summarize_lame_events %>%
  group_by(event_type) %>%
  summarise(n_y = n_distinct(event)) %>%
  arrange(desc(n_y)) %>%  # Order by most y categories
  pull(event_type)

# order events
summarize_lame_events <- summarize_lame_events %>%
  mutate(event_type = fct_reorder(event_type, count_rows, .fun = sum, .desc = FALSE)) 

  ggplot(summarize_lame_events)+
  geom_bar(aes(x = event_type,
               y = count_rows, fill = event_type), stat = "identity")+
  #facet_wrap(factor(event, levels = facet_order) ~., scales = 'free')+
    facet_wrap(vars(event), ncol = 1, scales = "free")+
  coord_flip()+
  scale_fill_viridis_d()+
  theme_minimal()+
  labs(x = "",
       y = "Row Count")+
  theme(legend.position = "none",
        # axis.text.y = element_text(size = 6)
  )
```

```{r}
# Lameness events by DIM and event type
library(dplyr)
library(ggplot2)
library(viridis)

# Summarize data
summarized_lame_events <- lame_data |> 
  group_by(dim_event, event, protocols_remaining_after_numbers1) |> 
  summarise(count_rows = n(), .groups = "drop") |> 
  mutate(event_type = factor(protocols_remaining_after_numbers1),
         event = factor(event),
         event_type = if_else(is.na(event_type), "Trim Only", event_type))

# Identify the top 5 most frequent event types
top_5_events <- summarized_lame_events |> 
  group_by(event_type) |> 
  summarise(total_count = sum(count_rows)) |> 
  arrange(desc(total_count)) |> 
  slice_head(n = 5) |> 
  pull(event_type)

# Filter dataset to include only top 5 event types
summarized_lame_events <- summarized_lame_events |> 
  filter(event_type %in% top_5_events)

# Plot stacked bar graph with 30-day tick marks on x-axis
ggplot(summarized_lame_events, aes(x = dim_event, y = count_rows, fill = event_type)) +
  geom_col(width = 14, position = "stack") +  # Use geom_col for numeric x-axis
  scale_fill_viridis_d() +  # Colorblind-friendly palette
  scale_x_continuous(breaks = seq(0, max(summarized_lame_events$dim_event), by = 60)) +  # Tick marks every 30 days
  theme_minimal(base_size = 14) +
  facet_wrap(vars(event), ncol = 1, scales = "free_y") +  # Separate facets for each event
  labs(
    title = "Stacked Bar Graph of Lameness Events by Days in Milk",
    x = "Days in Milk",
    y = "Count of Events",
    fill = "Event Type"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
    panel.grid.major = element_line(color = "gray80", size = 0.3),  # Thinner grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    strip.text = element_text(size = 14, face = "bold"),
    legend.position = "right"
  )

```

# Mastitis

```{r}



graph <- ggplot(mastitis_data, aes(x = dim_event)) +
  geom_histogram(binwidth = 10, fill = "steelblue", color = "black", alpha = 0.7) +
  theme_minimal(base_size = 14) +
  facet_wrap(vars(event), ncol = 1, scales = "free") +
  labs(
    title = "Distribution of Mastitis Events Over Days in Milk",
    x = "Days in Milk",
    y = "Count"
  ) +
  theme(
    panel.grid.major = element_line(color = "gray80"),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  )

print(graph)
```
